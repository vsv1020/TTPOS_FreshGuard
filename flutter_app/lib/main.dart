import 'dart:convert';

import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:shared_preferences/shared_preferences.dart';

const _sessionKey = 'freshguard_session';

void main() {
  runApp(const FreshGuardStoreApp());
}

class FreshGuardStoreApp extends StatefulWidget {
  const FreshGuardStoreApp({super.key});

  @override
  State<FreshGuardStoreApp> createState() => _FreshGuardStoreAppState();
}

class _FreshGuardStoreAppState extends State<FreshGuardStoreApp> {
  AppSession? _session;
  bool _loading = true;

  @override
  void initState() {
    super.initState();
    _loadSession();
  }

  Future<void> _loadSession() async {
    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getString(_sessionKey);
    if (raw != null && raw.isNotEmpty) {
      final data = jsonDecode(raw) as Map<String, dynamic>;
      _session = AppSession.fromJson(data);
    }

    if (!mounted) {
      return;
    }

    setState(() {
      _loading = false;
    });
  }

  Future<void> _onBound(AppSession session) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_sessionKey, jsonEncode(session.toJson()));
    if (!mounted) {
      return;
    }
    setState(() {
      _session = session;
    });
  }

  Future<void> _logout() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_sessionKey);
    if (!mounted) {
      return;
    }
    setState(() {
      _session = null;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'FreshGuard Store',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: const Color(0xFF0F766E)),
        useMaterial3: true,
      ),
      home: _loading
          ? const Scaffold(body: Center(child: CircularProgressIndicator()))
          : (_session == null
                ? BindScreen(onBound: _onBound)
                : DashboardScreen(session: _session!, onLogout: _logout)),
    );
  }
}

class BindScreen extends StatefulWidget {
  const BindScreen({super.key, required this.onBound});

  final ValueChanged<AppSession> onBound;

  @override
  State<BindScreen> createState() => _BindScreenState();
}

class _BindScreenState extends State<BindScreen> {
  final _baseUrlController = TextEditingController(text: 'http://10.0.2.2:4000');
  final _codeController = TextEditingController();
  final _deviceController = TextEditingController(text: 'android-flutter-device');

  bool _submitting = false;
  String? _error;

  Future<void> _bind() async {
    setState(() {
      _submitting = true;
      _error = null;
    });

    try {
      final api = ApiClient(baseUrl: _baseUrlController.text.trim());
      final session = await api.bindStore(
        code: _codeController.text.trim(),
        deviceId: _deviceController.text.trim(),
      );
      await widget.onBound(session);
    } catch (error) {
      setState(() {
        _error = error.toString().replaceFirst('Exception: ', '');
      });
    } finally {
      if (mounted) {
        setState(() {
          _submitting = false;
        });
      }
    }
  }

  @override
  void dispose() {
    _baseUrlController.dispose();
    _codeController.dispose();
    _deviceController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Card(
          margin: const EdgeInsets.all(16),
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 420),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Text('Bind Store Device', style: Theme.of(context).textTheme.headlineSmall),
                  const SizedBox(height: 8),
                  const Text('Use one-time binding code generated by admin.'),
                  const SizedBox(height: 16),
                  TextField(
                    controller: _baseUrlController,
                    decoration: const InputDecoration(labelText: 'Backend URL'),
                  ),
                  const SizedBox(height: 12),
                  TextField(
                    controller: _codeController,
                    decoration: const InputDecoration(labelText: 'Binding code'),
                  ),
                  const SizedBox(height: 12),
                  TextField(
                    controller: _deviceController,
                    decoration: const InputDecoration(labelText: 'Device ID'),
                  ),
                  if (_error != null) ...[
                    const SizedBox(height: 12),
                    Text(_error!, style: const TextStyle(color: Colors.red)),
                  ],
                  const SizedBox(height: 16),
                  FilledButton(
                    onPressed: _submitting ? null : _bind,
                    child: _submitting
                        ? const SizedBox(
                            width: 18,
                            height: 18,
                            child: CircularProgressIndicator(strokeWidth: 2),
                          )
                        : const Text('Bind'),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class DashboardScreen extends StatefulWidget {
  const DashboardScreen({
    super.key,
    required this.session,
    required this.onLogout,
  });

  final AppSession session;
  final VoidCallback onLogout;

  @override
  State<DashboardScreen> createState() => _DashboardScreenState();
}

class _DashboardScreenState extends State<DashboardScreen> {
  late final ApiClient _api;

  final _quantityController = TextEditingController(text: '1');

  List<ProductItem> _products = [];
  List<ReminderItem> _reminders = [];
  int? _selectedProductId;
  String _reminderStatus = 'expired';
  bool _busy = false;
  String? _message;

  @override
  void initState() {
    super.initState();
    _api = ApiClient(baseUrl: widget.session.baseUrl, token: widget.session.token);
    _loadAll();
  }

  Future<void> _loadAll() async {
    setState(() {
      _busy = true;
      _message = null;
    });

    try {
      final productsFuture = _api.fetchProducts();
      final remindersFuture = _api.fetchReminders(status: _reminderStatus);
      final products = await productsFuture;
      final reminders = await remindersFuture;

      if (!mounted) {
        return;
      }

      setState(() {
        _products = products;
        _reminders = reminders;
        _selectedProductId = _selectedProductId ?? (products.isNotEmpty ? products.first.id : null);
      });
    } catch (error) {
      if (!mounted) {
        return;
      }
      setState(() {
        _message = error.toString().replaceFirst('Exception: ', '');
      });
    } finally {
      if (mounted) {
        setState(() {
          _busy = false;
        });
      }
    }
  }

  Future<void> _printBatch() async {
    if (_selectedProductId == null) {
      setState(() {
        _message = 'Select a product before printing.';
      });
      return;
    }

    final quantity = int.tryParse(_quantityController.text.trim());
    if (quantity == null || quantity <= 0) {
      setState(() {
        _message = 'Quantity must be a positive integer.';
      });
      return;
    }

    setState(() {
      _busy = true;
      _message = null;
    });

    try {
      final result = await _api.printLabels(productId: _selectedProductId!, quantity: quantity);
      final reminders = await _api.fetchReminders(status: _reminderStatus);

      if (!mounted) {
        return;
      }

      setState(() {
        _reminders = reminders;
        _message =
            'Batch ${result.batchId} created. ${result.remindersCreated} reminders generated for expiry tracking.';
      });
    } catch (error) {
      if (!mounted) {
        return;
      }
      setState(() {
        _message = error.toString().replaceFirst('Exception: ', '');
      });
    } finally {
      if (mounted) {
        setState(() {
          _busy = false;
        });
      }
    }
  }

  Future<void> _handleReminder(ReminderItem reminder, String reason) async {
    setState(() {
      _busy = true;
      _message = null;
    });

    try {
      await _api.handleReminder(reminderId: reminder.id, reason: reason);
      final reminders = await _api.fetchReminders(status: _reminderStatus);

      if (!mounted) {
        return;
      }

      setState(() {
        _reminders = reminders;
        _message = 'Reminder ${reminder.id} marked as $reason.';
      });
    } catch (error) {
      if (!mounted) {
        return;
      }
      setState(() {
        _message = error.toString().replaceFirst('Exception: ', '');
      });
    } finally {
      if (mounted) {
        setState(() {
          _busy = false;
        });
      }
    }
  }

  @override
  void dispose() {
    _quantityController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 2,
      child: Scaffold(
        appBar: AppBar(
          title: Text('${widget.session.brandName} / ${widget.session.storeName}'),
          bottom: const TabBar(
            tabs: [
              Tab(text: 'Products & Print'),
              Tab(text: 'Reminders'),
            ],
          ),
          actions: [
            IconButton(onPressed: _busy ? null : _loadAll, icon: const Icon(Icons.refresh)),
            IconButton(onPressed: widget.onLogout, icon: const Icon(Icons.logout)),
          ],
        ),
        body: Column(
          children: [
            if (_busy) const LinearProgressIndicator(),
            if (_message != null)
              Padding(
                padding: const EdgeInsets.all(12),
                child: Text(
                  _message!,
                  style: TextStyle(
                    color: _message!.toLowerCase().contains('error') ? Colors.red : Colors.black,
                  ),
                ),
              ),
            Expanded(
              child: TabBarView(
                children: [
                  _buildProductsTab(context),
                  _buildRemindersTab(context),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildProductsTab(BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(12),
      children: [
        Card(
          child: Padding(
            padding: const EdgeInsets.all(12),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text('Print Labels', style: Theme.of(context).textTheme.titleMedium),
                const SizedBox(height: 12),
                DropdownButtonFormField<int>(
                  value: _selectedProductId,
                  items: _products
                      .map(
                        (item) => DropdownMenuItem<int>(
                          value: item.id,
                          child: Text('${item.name} (${item.shelfLifeDays}d)'),
                        ),
                      )
                      .toList(),
                  onChanged: (value) => setState(() {
                    _selectedProductId = value;
                  }),
                  decoration: const InputDecoration(labelText: 'Product'),
                ),
                const SizedBox(height: 12),
                TextField(
                  controller: _quantityController,
                  keyboardType: TextInputType.number,
                  decoration: const InputDecoration(labelText: 'Quantity'),
                ),
                const SizedBox(height: 12),
                FilledButton(
                  onPressed: _busy ? null : _printBatch,
                  child: const Text('Print (Generate Batch)'),
                ),
              ],
            ),
          ),
        ),
        const SizedBox(height: 8),
        Text('Available Products', style: Theme.of(context).textTheme.titleMedium),
        const SizedBox(height: 8),
        ..._products.map(
          (item) => Card(
            child: ListTile(
              title: Text(item.name),
              subtitle: Text(
                'SKU: ${item.sku ?? '-'} | Shelf life: ${item.shelfLifeDays} day(s) | Label: ${item.labelLanguage}',
              ),
            ),
          ),
        ),
        if (_products.isEmpty)
          const Card(
            child: ListTile(title: Text('No products found for this store brand.')),
          ),
      ],
    );
  }

  Widget _buildRemindersTab(BuildContext context) {
    return Column(
      children: [
        Padding(
          padding: const EdgeInsets.all(12),
          child: Row(
            children: [
              ChoiceChip(
                label: const Text('Expired'),
                selected: _reminderStatus == 'expired',
                onSelected: (selected) {
                  if (!selected) {
                    return;
                  }
                  setState(() {
                    _reminderStatus = 'expired';
                  });
                  _loadAll();
                },
              ),
              const SizedBox(width: 8),
              ChoiceChip(
                label: const Text('Expiring'),
                selected: _reminderStatus == 'expiring',
                onSelected: (selected) {
                  if (!selected) {
                    return;
                  }
                  setState(() {
                    _reminderStatus = 'expiring';
                  });
                  _loadAll();
                },
              ),
            ],
          ),
        ),
        Expanded(
          child: ListView.builder(
            padding: const EdgeInsets.symmetric(horizontal: 12),
            itemCount: _reminders.length,
            itemBuilder: (context, index) {
              final reminder = _reminders[index];
              return Card(
                child: Padding(
                  padding: const EdgeInsets.all(12),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(reminder.productName, style: Theme.of(context).textTheme.titleMedium),
                      const SizedBox(height: 4),
                      Text('Reminder #${reminder.id} | Expires: ${reminder.expiresAt}'),
                      const SizedBox(height: 10),
                      Wrap(
                        spacing: 8,
                        children: [
                          OutlinedButton(
                            onPressed: _busy ? null : () => _handleReminder(reminder, 'discarded'),
                            child: const Text('Discarded'),
                          ),
                          OutlinedButton(
                            onPressed: _busy ? null : () => _handleReminder(reminder, 'sold'),
                            child: const Text('Sold'),
                          ),
                          OutlinedButton(
                            onPressed: _busy ? null : () => _handleReminder(reminder, 'transferred'),
                            child: const Text('Transferred'),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
        ),
        if (_reminders.isEmpty)
          const Padding(
            padding: EdgeInsets.all(20),
            child: Text('No reminders for this filter.'),
          ),
      ],
    );
  }
}

class ApiClient {
  ApiClient({required this.baseUrl, this.token});

  final String baseUrl;
  final String? token;

  Future<Map<String, dynamic>> _request(
    String path, {
    String method = 'GET',
    Map<String, dynamic>? body,
  }) async {
    final uri = Uri.parse('$baseUrl$path');
    final headers = <String, String>{'Content-Type': 'application/json'};
    if (token != null && token!.isNotEmpty) {
      headers['Authorization'] = 'Bearer $token';
    }

    http.Response response;
    if (method == 'POST') {
      response = await http.post(uri, headers: headers, body: jsonEncode(body ?? {}));
    } else {
      response = await http.get(uri, headers: headers);
    }

    final parsed = response.body.isEmpty
        ? <String, dynamic>{}
        : (jsonDecode(response.body) as Map<String, dynamic>);

    if (response.statusCode >= 400) {
      final error = parsed['error']?.toString() ?? 'HTTP ${response.statusCode}';
      throw Exception(error);
    }

    return parsed;
  }

  Future<AppSession> bindStore({required String code, required String deviceId}) async {
    final result = await _request(
      '/api/store/bind',
      method: 'POST',
      body: {
        'code': code,
        'deviceId': deviceId,
      },
    );

    final store = result['store'] as Map<String, dynamic>;
    return AppSession(
      baseUrl: baseUrl,
      token: result['token'] as String,
      storeId: (store['id'] as num).toInt(),
      brandId: (store['brandId'] as num).toInt(),
      storeName: store['name'] as String,
      brandName: store['brandName'] as String? ?? 'Brand',
    );
  }

  Future<List<ProductItem>> fetchProducts() async {
    final result = await _request('/api/store/products');
    final items = result['products'] as List<dynamic>? ?? [];
    return items.map((item) => ProductItem.fromJson(item as Map<String, dynamic>)).toList();
  }

  Future<PrintResult> printLabels({required int productId, required int quantity}) async {
    final result = await _request(
      '/api/store/print',
      method: 'POST',
      body: {
        'productId': productId,
        'quantity': quantity,
      },
    );

    final batch = result['batch'] as Map<String, dynamic>;
    return PrintResult(
      batchId: (batch['id'] as num).toInt(),
      remindersCreated: (result['remindersCreated'] as num).toInt(),
    );
  }

  Future<List<ReminderItem>> fetchReminders({required String status}) async {
    final query = Uri(queryParameters: {'status': status}).query;
    final result = await _request('/api/store/reminders?$query');
    final items = result['reminders'] as List<dynamic>? ?? [];
    return items.map((item) => ReminderItem.fromJson(item as Map<String, dynamic>)).toList();
  }

  Future<void> handleReminder({required int reminderId, required String reason}) async {
    await _request(
      '/api/store/reminders/$reminderId/handle',
      method: 'POST',
      body: {'reason': reason},
    );
  }
}

class AppSession {
  const AppSession({
    required this.baseUrl,
    required this.token,
    required this.storeId,
    required this.brandId,
    required this.storeName,
    required this.brandName,
  });

  final String baseUrl;
  final String token;
  final int storeId;
  final int brandId;
  final String storeName;
  final String brandName;

  Map<String, dynamic> toJson() {
    return {
      'baseUrl': baseUrl,
      'token': token,
      'storeId': storeId,
      'brandId': brandId,
      'storeName': storeName,
      'brandName': brandName,
    };
  }

  factory AppSession.fromJson(Map<String, dynamic> json) {
    return AppSession(
      baseUrl: json['baseUrl'] as String,
      token: json['token'] as String,
      storeId: (json['storeId'] as num).toInt(),
      brandId: (json['brandId'] as num).toInt(),
      storeName: json['storeName'] as String,
      brandName: json['brandName'] as String,
    );
  }
}

class ProductItem {
  const ProductItem({
    required this.id,
    required this.name,
    required this.sku,
    required this.shelfLifeDays,
    required this.labelLanguage,
  });

  final int id;
  final String name;
  final String? sku;
  final int shelfLifeDays;
  final String labelLanguage;

  factory ProductItem.fromJson(Map<String, dynamic> json) {
    return ProductItem(
      id: (json['id'] as num).toInt(),
      name: json['name'] as String,
      sku: json['sku'] as String?,
      shelfLifeDays: (json['shelfLifeDays'] as num).toInt(),
      labelLanguage: json['labelLanguage'] as String,
    );
  }
}

class ReminderItem {
  const ReminderItem({
    required this.id,
    required this.productName,
    required this.expiresAt,
  });

  final int id;
  final String productName;
  final String expiresAt;

  factory ReminderItem.fromJson(Map<String, dynamic> json) {
    return ReminderItem(
      id: (json['id'] as num).toInt(),
      productName: json['productName'] as String,
      expiresAt: json['expiresAt'] as String,
    );
  }
}

class PrintResult {
  const PrintResult({
    required this.batchId,
    required this.remindersCreated,
  });

  final int batchId;
  final int remindersCreated;
}
